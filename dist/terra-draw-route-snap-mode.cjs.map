{"version":3,"file":"terra-draw-route-snap-mode.cjs","sources":["../src/kdbush/kdbush.ts","../src/kdbush/tinyqueue.ts","../src/kdbush/geokdbush.ts","../src/routing.ts","../src/terra-draw-route-snap-mode.ts"],"sourcesContent":["// Adapted from https://github.com/mourner/kdbush\n\n// ISC License\n\n// Copyright (c) 2018, Vladimir Agafonkin\n\n// Permission to use, copy, modify, and/or distribute this software for any purpose\n// with or without fee is hereby granted, provided that the above copyright notice\n// and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n// FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n// OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n// THIS SOFTWARE.\n\nconst ARRAY_TYPES = [\n    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array\n];\n\nconst VERSION = 1;\nconst HEADER_SIZE = 8;\n\nexport class KDBush {\n    private data: ArrayBuffer;\n    public ids: Uint16Array | Uint32Array;\n    public coords: InstanceType<TypedArrayConstructor>;\n    private _pos: number;\n    private _finished: boolean;\n    private numItems: number;\n    public nodeSize: number;\n    private ArrayType: TypedArrayConstructor;\n    private IndexArrayType: typeof Uint16Array | typeof Uint32Array;\n\n    constructor(\n        numItems: number,\n        nodeSize: number = 64,\n        ArrayType: TypedArrayConstructor = Float64Array,\n        data?: ArrayBuffer\n    ) {\n        if (isNaN(numItems) || numItems < 0) {\n            throw new Error(`Unexpected numItems value: ${numItems}.`);\n        }\n\n        this.numItems = numItems;\n        this.nodeSize = Math.min(Math.max(nodeSize, 2), 65535);\n        this.ArrayType = ArrayType;\n        this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;\n\n        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n        const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;\n        const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;\n        const padCoords = (8 - idsByteSize % 8) % 8;\n\n        if (arrayTypeIndex < 0) {\n            throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n        }\n\n        if (data) {\n            this.data = data;\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = numItems * 2;\n            this._finished = true;\n        } else {\n            this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = 0;\n            this._finished = false;\n\n            new Uint8Array(this.data, 0, 2).set([0xdb, (VERSION << 4) + arrayTypeIndex]);\n            new Uint16Array(this.data, 2, 1)[0] = this.nodeSize;\n            new Uint32Array(this.data, 4, 1)[0] = this.numItems;\n        }\n    }\n\n    add(x: number, y: number): number {\n        const index = this._pos >> 1;\n        this.ids[index] = index;\n        this.coords[this._pos++] = x;\n        this.coords[this._pos++] = y;\n        return index;\n    }\n\n    finish(): this {\n        const numAdded = this._pos >> 1;\n        if (numAdded !== this.numItems) {\n            throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);\n        }\n        sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);\n        this._finished = true;\n        return this;\n    }\n}\n\ntype TypedArrayConstructor =\n    Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor |\n    Int16ArrayConstructor | Uint16ArrayConstructor |\n    Int32ArrayConstructor | Uint32ArrayConstructor |\n    Float32ArrayConstructor | Float64ArrayConstructor;\n\nfunction sort(\n    ids: Uint16Array | Uint32Array,\n    coords: InstanceType<TypedArrayConstructor>,\n    nodeSize: number,\n    left: number,\n    right: number,\n    axis: number\n): void {\n    if (right - left <= nodeSize) return;\n    const m = (left + right) >> 1;\n    select(ids, coords, m, left, right, axis);\n    sort(ids, coords, nodeSize, left, m - 1, 1 - axis);\n    sort(ids, coords, nodeSize, m + 1, right, 1 - axis);\n}\n\nfunction select(\n    ids: Uint16Array | Uint32Array,\n    coords: InstanceType<TypedArrayConstructor>,\n    k: number,\n    left: number,\n    right: number,\n    axis: number\n): void {\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, axis);\n        }\n\n        const t = coords[2 * k + axis];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + axis] > t) {\n            swapItem(ids, coords, left, right);\n        }\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + axis] < t) i++;\n            while (coords[2 * j + axis] > t) j--;\n        }\n\n        if (coords[2 * left + axis] === t) {\n            swapItem(ids, coords, left, j);\n        } else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(\n    ids: Uint16Array | Uint32Array,\n    coords: InstanceType<TypedArrayConstructor>,\n    i: number,\n    j: number\n): void {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap<T extends Uint16Array | Uint32Array | Float32Array | Float64Array | Int8Array | Int16Array | Int32Array | Uint8Array | Uint8ClampedArray>(\n    arr: T,\n    i: number,\n    j: number\n): void {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","// Adapted from https://github.com/mourner/kdbush\n\n// ISC License\n\n// Copyright (c) 2017, Vladimir Agafonkin\n\n// Permission to use, copy, modify, and/or distribute this software for any purpose\n// with or without fee is hereby granted, provided that the above copyright notice\n// and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n// FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n// OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n// THIS SOFTWARE.\n\nexport default class TinyQueue<T> {\n\n    private data: T[];\n    public length: number;\n    private compare: (a: T, b: T) => number;\n\n    constructor(\n        data: T[] = [],\n        compare: (a: T, b: T) => number = (a, b) =>\n            a < b ? -1 : a > b ? 1 : 0\n    ) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) {\n                this._down(i);\n            }\n        }\n    }\n\n    push(item: T): void {\n        this.data.push(item);\n        this._up(this.length++);\n    }\n\n    pop(): T | undefined {\n        if (this.length === 0) {\n            return undefined;\n        }\n\n        const top = this.data[0];\n        const bottom = this.data.pop() as T;\n\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek(): T | undefined {\n        return this.data[0];\n    }\n\n    private _up(pos: number): void {\n        const { data, compare } = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) {\n                break;\n            }\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    private _down(pos: number): void {\n        const { data, compare } = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let bestChild = (pos << 1) + 1;\n            const right = bestChild + 1;\n\n            if (right < this.length && compare(data[right], data[bestChild]) < 0) {\n                bestChild = right;\n            }\n\n            if (compare(data[bestChild], item) >= 0) {\n                break;\n            }\n\n            data[pos] = data[bestChild];\n            pos = bestChild;\n        }\n\n        data[pos] = item;\n    }\n}\n","// Adapted from https://github.com/mourner/geokdbush\n\n// ISC License\n\n// Copyright (c) 2017, Vladimir Agafonkin\n\n// Permission to use, copy, modify, and/or distribute this software for any purpose\n// with or without fee is hereby granted, provided that the above copyright notice\n// and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n// FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n// OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n// THIS SOFTWARE.\n\nimport { KDBush } from './kdbush';\nimport TinyQueue from './tinyqueue';\n\nconst earthRadius = 6371;\nconst rad = Math.PI / 180;\n\n\nexport function around(index: KDBush, lng: number, lat: number, maxResults = Infinity, maxDistance = Infinity) {\n    let maxHaverSinDist = 1;\n    const result = [];\n\n    if (maxResults === undefined) maxResults = Infinity;\n    if (maxDistance !== undefined) maxHaverSinDist = haverSin(maxDistance / earthRadius);\n\n    // a distance-sorted priority queue that will contain both points and kd-tree nodes\n    const q = new TinyQueue([], compareDist);\n\n    // an object that represents the top kd-tree node (the whole Earth)\n    let node = {\n        left: 0, // left index in the kd-tree array\n        right: index.ids.length - 1, // right index\n        axis: 0, // 0 for longitude axis and 1 for latitude axis\n        dist: 0, // will hold the lower bound of children's distances to the query point\n        minLng: -180, // bounding box of the node\n        minLat: -90,\n        maxLng: 180,\n        maxLat: 90\n    };\n\n    const cosLat = Math.cos(lat * rad);\n\n    while (node) {\n        const right = node.right;\n        const left = node.left;\n\n        if (right - left <= index.nodeSize) { // leaf node\n\n            // add all points of the leaf node to the queue\n            for (let i = left; i <= right; i++) {\n                const id = index.ids[i];\n\n                const dist = haverSinDist(lng, lat, index.coords[2 * i], index.coords[2 * i + 1], cosLat);\n                q.push({ id, dist });\n            }\n\n        } else { // not a leaf node (has child nodes)\n\n            const m = (left + right) >> 1; // middle index\n            const midLng = index.coords[2 * m];\n            const midLat = index.coords[2 * m + 1];\n\n            // add middle point to the queue\n            const id = index.ids[m];\n            const dist = haverSinDist(lng, lat, midLng, midLat, cosLat);\n            q.push({ id, dist });\n\n\n            const nextAxis = (node.axis + 1) % 2;\n\n            // first half of the node\n            const leftNode = {\n                left,\n                right: m - 1,\n                axis: nextAxis,\n                minLng: node.minLng,\n                minLat: node.minLat,\n                maxLng: node.axis === 0 ? midLng : node.maxLng,\n                maxLat: node.axis === 1 ? midLat : node.maxLat,\n                dist: 0\n            };\n            // second half of the node\n            const rightNode = {\n                left: m + 1,\n                right,\n                axis: nextAxis,\n                minLng: node.axis === 0 ? midLng : node.minLng,\n                minLat: node.axis === 1 ? midLat : node.minLat,\n                maxLng: node.maxLng,\n                maxLat: node.maxLat,\n                dist: 0\n            };\n\n            leftNode.dist = boxDist(lng, lat, cosLat, leftNode);\n            rightNode.dist = boxDist(lng, lat, cosLat, rightNode);\n\n            // add child nodes to the queue\n            q.push(leftNode);\n            q.push(rightNode);\n        }\n\n        // fetch closest points from the queue; they're guaranteed to be closer\n        // than all remaining points (both individual and those in kd-tree nodes),\n        // since each node's distance is a lower bound of distances to its children\n        while (q.length && q.peek().id != null) {\n            const candidate = q.pop()!;\n            if (candidate.dist > maxHaverSinDist) return result;\n            result.push(candidate.id);\n            if (result.length === maxResults) return result;\n        }\n\n        // the next closest kd-tree node\n        node = q.pop();\n    }\n\n    return result;\n}\n\n// lower bound for distance from a location to points inside a bounding box\nfunction boxDist(lng: number, lat: number, cosLat: number, node: any) {\n    const minLng = node.minLng;\n    const maxLng = node.maxLng;\n    const minLat = node.minLat;\n    const maxLat = node.maxLat;\n\n    // query point is between minimum and maximum longitudes\n    if (lng >= minLng && lng <= maxLng) {\n        if (lat < minLat) return haverSin((lat - minLat) * rad);\n        if (lat > maxLat) return haverSin((lat - maxLat) * rad);\n        return 0;\n    }\n\n    // query point is west or east of the bounding box;\n    // calculate the extremum for great circle distance from query point to the closest longitude;\n    const haverSinDLng = Math.min(haverSin((lng - minLng) * rad), haverSin((lng - maxLng) * rad));\n    const extremumLat = vertexLat(lat, haverSinDLng);\n\n    // if extremum is inside the box, return the distance to it\n    if (extremumLat > minLat && extremumLat < maxLat) {\n        return haverSinDistPartial(haverSinDLng, cosLat, lat, extremumLat);\n    }\n    // otherwise return the distan e to one of the bbox corners (whichever is closest)\n    return Math.min(\n        haverSinDistPartial(haverSinDLng, cosLat, lat, minLat),\n        haverSinDistPartial(haverSinDLng, cosLat, lat, maxLat)\n    );\n}\n\nfunction compareDist(a: any, b: any) {\n    return a.dist - b.dist;\n}\n\nfunction haverSin(theta: number) {\n    const s = Math.sin(theta / 2);\n    return s * s;\n}\n\nfunction haverSinDistPartial(haverSinDLng: number, cosLat1: number, lat1: number, lat2: number) {\n    return cosLat1 * Math.cos(lat2 * rad) * haverSinDLng + haverSin((lat1 - lat2) * rad);\n}\n\nfunction haverSinDist(lng1: number, lat1: number, lng2: number, lat2: number, cosLat1: number) {\n    const haverSinDLng = haverSin((lng1 - lng2) * rad);\n    return haverSinDistPartial(haverSinDLng, cosLat1, lat1, lat2);\n}\n\nexport function distance(lng1: number, lat1: number, lng2: number, lat2: number) {\n    const h = haverSinDist(lng1, lat1, lng2, lat2, Math.cos(lat1 * rad));\n    return 2 * earthRadius * Math.asin(Math.sqrt(h));\n}\n\nfunction vertexLat(lat: number, haverSinDLng: number) {\n    const cosDLng = 1 - 2 * haverSinDLng;\n    if (cosDLng <= 0) return lat > 0 ? 90 : -90;\n    return Math.atan(Math.tan(lat * rad) / cosDLng) / rad;\n}","import { KDBush } from \"./kdbush/kdbush\";\nimport { around } from \"./kdbush/geokdbush\";\nimport {\n  FeatureCollection,\n  LineString,\n  Position,\n  Feature,\n  Point,\n} from \"geojson\";\n\nexport type RouteFinder = {\n  getRoute: (positionA: Feature<Point>, positionB: Feature<Point>) => Feature<LineString> | null\n  setNetwork: (network: FeatureCollection<LineString>) => void\n  expandNetwork: (additionalNetwork: FeatureCollection<LineString>) => void\n}\n\nexport interface RoutingInterface {\n  getRoute: (\n    startCoord: Position,\n    endCoord: Position\n  ) => Feature<LineString> | null;\n  getClosestNetworkCoordinate: (coordinate: Position) => Position | null;\n  getNodeCount: () => number;\n  getClosestNetworkCoordinates: (\n    coordinate: Position,\n    maxResults: number,\n    maxDistance: number\n  ) => Position[];\n  expandRouteNetwork: (additionalNetwork: FeatureCollection<LineString>) => void;\n  setRouteFinder: (routeFinder: RouteFinder) => void;\n  setNetwork: (network: FeatureCollection<LineString>) => void\n}\n\n/**\n * Routing class for finding routes on a network of LineStrings.\n * The LineString network must have coordinates that are shared between\n * the LineStrings in order to find a route.\n */\nexport class Routing implements RoutingInterface {\n  constructor(options: {\n    network: FeatureCollection<LineString>, useCache?: boolean,\n    routeFinder: RouteFinder\n  }) {\n    this.useCache = options.useCache !== undefined ? options.useCache : true;\n    this.network = this.clone(options.network);\n    this.routeFinder = options.routeFinder;\n\n    this.initialise();\n  }\n\n  private useCache: boolean = true;\n  private indexedNetworkPoints!: KDBush;\n  private points: Position[] = []\n  private routeFinder: RouteFinder;\n  private network: FeatureCollection<LineString>;\n  private routeCache: Record<string, Feature<LineString> | null> = {};\n\n  // Initialise the routing instance setting internal data structures\n  private initialise() {\n    this.network.features.forEach((feature) => {\n      feature.geometry.coordinates.forEach((coordinate) => {\n        this.points.push(coordinate);\n      });\n    });\n\n    this.indexedNetworkPoints = new KDBush(this.points.length);\n\n    this.points.forEach(coordinate => {\n      this.indexedNetworkPoints.add(coordinate[0], coordinate[1]);\n    })\n\n    this.indexedNetworkPoints.finish();\n\n    this.routeCache = {};\n  }\n\n  public getNodeCount() {\n    return this.indexedNetworkPoints.ids.length;\n  }\n\n  /**\n   * Return the closest network coordinate to the input coordinate\n   * @param inputCoordinate The coordinate to find the closest network coordinate to\n   * @returns a coordinate on the network or null if no coordinate is found\n   */\n  public getClosestNetworkCoordinate(inputCoordinate: Position) {\n    const aroundInput: number[] = around(\n      this.indexedNetworkPoints,\n      inputCoordinate[0],\n      inputCoordinate[1],\n      1\n    );\n\n    const nearest = this.points[aroundInput[0]]\n    return nearest ? nearest : null;\n  }\n\n  public getClosestNetworkCoordinates(\n    inputCoordinate: Position,\n    maxResults: number,\n    maxDistance: number\n  ) {\n    const aroundInput: number[] = around(\n      this.indexedNetworkPoints,\n      inputCoordinate[0],\n      inputCoordinate[1],\n      maxResults,\n      maxDistance\n    );\n\n    const nearestCoordinates: Position[] = [];\n    aroundInput.forEach((index) => {\n      nearestCoordinates.push(this.points[index]);\n    });\n\n    return nearestCoordinates;\n  }\n\n  /**\n   * Set the route finder for the routing instance\n   * @param routeFinder The route finder to use\n   */\n  public setRouteFinder(routeFinder: RouteFinder) {\n    this.routeFinder = routeFinder;\n  }\n\n  /**\n   * Set the network for the routing instance\n   * @param network The network to use\n   */\n  public setNetwork(network: FeatureCollection<LineString>) {\n    this.network = this.clone(network);\n\n    // Ensure the network is updated correctly for the router finder\n    this.routeFinder.setNetwork(network);\n\n    // Re-initialize all internal data structures for this class\n    this.initialise();\n  }\n\n  public expandRouteNetwork(additionalNetwork: FeatureCollection<LineString>) {\n    const clonedNetwork = this.clone(additionalNetwork);\n\n    // Ensure the network is updated correctly for the router finder\n    this.routeFinder.expandNetwork(clonedNetwork);\n\n    const mergedNetwork = {\n      type: \"FeatureCollection\",\n      features: [...clonedNetwork.features, ...this.network.features]\n    } as FeatureCollection<LineString>;\n\n    this.network = mergedNetwork;\n\n    // Re-initialize all internal data structures for this class\n    // TODO: Is there a way to avoid re-initialising here?\n    this.initialise();\n  }\n\n  /**\n   * Get the route between two coordinates returned as a GeoJSON LineString\n   * @param startCoord start coordinate\n   * @param endCoord end coordinate\n   * @returns The route as a GeoJSON LineString\n   */\n  public getRoute(startCoord: Position, endCoord: Position): Feature<LineString> | null {\n\n    // Check if caching is enabled, and if the coordinates are already in the cache  \n    if (this.useCache) {\n      const routeKey = `${startCoord}-${endCoord}`;\n\n      // Use 'in' to account for the route potentially being null\n      if (routeKey in this.routeCache) {\n        return this.routeCache[routeKey];\n      }\n    }\n\n    const start = {\n      type: \"Feature\",\n      geometry: {\n        type: \"Point\",\n        coordinates: startCoord,\n      },\n      properties: {},\n    } as Feature<Point>;\n\n    const end = {\n      type: \"Feature\",\n      geometry: {\n        type: \"Point\",\n        coordinates: endCoord,\n      },\n      properties: {},\n    } as Feature<Point>;\n\n    const route = this.routeFinder.getRoute(start, end);\n\n    // If caching is enabled, store the route in the cache\n    if (this.useCache) {\n      const routeKey = `${startCoord}-${endCoord}`\n      this.routeCache[routeKey] = route;\n      return route;\n    }\n\n    return route;\n\n  }\n\n  private clone(network: FeatureCollection<LineString>) {\n    return JSON.parse(JSON.stringify(network)) as FeatureCollection<LineString>;\n  }\n}\n","import {\n  TerraDrawAdapterStyling,\n  TerraDrawKeyboardEvent,\n  TerraDrawMouseEvent,\n  BehaviorConfig,\n  GeoJSONStoreFeatures,\n  TerraDrawExtend\n} from \"terra-draw\";\nimport { Feature, LineString, Position } from \"geojson\";\nimport { Validation } from \"terra-draw/dist/common\";\nimport { RoutingInterface } from \"./routing\";\nimport { FeatureId } from \"terra-draw/dist/extend\";\n\ntype TerraDrawRouteSnapModeKeyEvents = {\n  cancel: KeyboardEvent[\"key\"] | null;\n  finish: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ninterface Cursors {\n  draw?: TerraDrawExtend.Cursor;\n  close?: TerraDrawExtend.Cursor;\n}\n\nconst defaultCursors = {\n  draw: \"crosshair\",\n  close: \"pointer\"\n} as Required<Cursors>;\n\ntype RouteSnapStyling = {\n  lineStringWidth: TerraDrawExtend.NumericStyling;\n  lineStringColor: TerraDrawExtend.HexColorStyling\n  routePointColor: TerraDrawExtend.HexColorStyling;\n  routePointWidth: TerraDrawExtend.NumericStyling;\n  routePointOutlineColor: TerraDrawExtend.HexColorStyling;\n  routePointOutlineWidth: TerraDrawExtend.NumericStyling;\n};\n\ninterface TerraDrawRouteSnapModeOptions<T extends TerraDrawExtend.CustomStyling>\n  extends TerraDrawExtend.BaseModeOptions<T> {\n  routing: RoutingInterface;\n  pointerDistance?: number;\n  keyEvents?: TerraDrawRouteSnapModeKeyEvents | null;\n  maxPoints?: number;\n  cursors?: Partial<Cursors>;\n  straightLineFallback?: boolean;\n}\n\nconst { TerraDrawBaseDrawMode } = TerraDrawExtend;\n\nexport class TerraDrawRouteSnapMode extends TerraDrawBaseDrawMode<RouteSnapStyling> {\n  mode = \"routesnap\" as const;\n\n  private currentCoordinate = 0;\n  private currentId: FeatureId | undefined;\n  private keyEvents: TerraDrawRouteSnapModeKeyEvents = defaultKeyEvents;\n  private cursors: Required<Cursors> = defaultCursors;\n\n  private maxPoints: number = 2\n  private moveLineId: FeatureId | undefined;\n  private routing!: RoutingInterface;\n  private currentPointIds: FeatureId[] = [];\n  private routeId = 0;\n  private latestMouseMoveEvent: TerraDrawMouseEvent | null = null;\n  private straightLineFallback: boolean = false;\n\n  // When straight-line fallback is enabled, we persist whether the user is currently\n  // drawing off-network with straight segments (committed via click).\n  private isDrawingStraightLine = false;\n\n  // We keep track of whether the current route incremented routeId so that we\n  // can roll it back on cancel/cleanup (so cancelled routes don't consume ids).\n  private didIncrementRouteIdForCurrentRoute = false;\n\n  constructor(options?: TerraDrawRouteSnapModeOptions<RouteSnapStyling>) {\n    super(options, true);\n    this.updateOptions(options);\n  }\n\n  override updateOptions(options?: Partial<TerraDrawRouteSnapModeOptions<RouteSnapStyling>>) {\n    super.updateOptions(options);\n\n    if (options?.routing && options.routing !== this.routing) {\n      // We can't guarantee the rout created so far is valid with the new routing \n      // So we need to clean up the current state\n      this.cleanUp();\n      this.routing = options.routing;\n    }\n\n    if (options?.maxPoints !== undefined && options.maxPoints !== this.maxPoints && options.maxPoints >= 2) {\n      this.maxPoints = options.maxPoints;\n    }\n\n    if (options?.cursors) {\n      this.cursors = { ...this.cursors, ...options.cursors };\n    }\n\n    // null is the case where we want to explicitly turn key bindings off\n    if (options?.keyEvents === null) {\n      this.keyEvents = { cancel: null, finish: null };\n    } else if (options?.keyEvents) {\n      this.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n    }\n\n    if (options?.straightLineFallback !== undefined) {\n      this.straightLineFallback = options.straightLineFallback;\n    }\n  }\n\n  private pixelDistance = (\n    pointOne: { x: number; y: number },\n    pointTwo: { x: number; y: number }\n  ) => {\n    const { x: xOne, y: yOne } = pointOne;\n    const { x: xTwo, y: yTwo } = pointTwo;\n\n    const deltaX = xTwo - xOne;\n    const deltaY = yTwo - yOne;\n\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  };\n\n  private measure(clickEvent: TerraDrawMouseEvent, secondCoordinate: Position) {\n    const { x, y } = this.project(secondCoordinate[0], secondCoordinate[1]);\n\n    const distance = this.pixelDistance(\n      { x, y },\n      { x: clickEvent.containerX, y: clickEvent.containerY }\n    );\n\n    return distance;\n  }\n\n  private measureCoordinateToCoordinate(coordinateOne: Position, coordinateTwo: Position) {\n    const { x, y } = this.project(coordinateOne[0], coordinateOne[1]);\n    const previousEvent = {\n      lng: coordinateOne[0],\n      lat: coordinateOne[1],\n      containerX: x,\n      containerY: y,\n      button: 'left' as const,\n      heldKeys: []\n    }\n    const distToPrevious = this.measure(previousEvent, coordinateTwo);\n\n    return distToPrevious\n  }\n\n\n  private close() {\n    if (!this.currentId) {\n      return;\n    }\n\n    // Reset the state back to starting state\n    this.currentCoordinate = 0;\n    this.currentId = undefined;\n    this.currentPointIds = [];\n    this.isDrawingStraightLine = false;\n\n    // Go back to started state\n    if (this.state === \"drawing\") {\n      this.setStarted();\n    }\n  }\n\n  private finish() {\n    if (!this.currentId) {\n      return;\n    }\n\n    // Route is now completed; don't allow cleanUp() to roll back the id.\n    this.didIncrementRouteIdForCurrentRoute = false;\n\n    // When finishing a route, we keep the route LineString but remove any temporary\n    // route points and preview (move) line segments.\n    const deletable = [this.moveLineId, ...this.currentPointIds].filter(\n      (id): id is FeatureId => Boolean(id) && this.store.has(id as FeatureId)\n    );\n\n    if (deletable.length) {\n      this.store.delete(deletable);\n    }\n\n    this.close();\n  }\n\n  private getFeatureProperties() {\n    return { mode: this.mode, isDrawnRoute: true, routeId: this.routeId };\n  }\n\n  private getStraightLineString(coordinates: Position[]) {\n    return {\n      type: \"Feature\",\n      geometry: {\n        type: \"LineString\",\n        coordinates,\n      },\n      properties: this.getFeatureProperties(),\n    } as Feature<LineString>;\n  }\n\n  private createRoutePoint(position: Position) {\n    const [createdId] = this.store.create([\n      {\n        geometry: {\n          type: \"Point\",\n          coordinates: position,\n        },\n        properties: this.getFeatureProperties(),\n      },\n    ]);\n\n    return createdId;\n  }\n\n  private updateRoute({\n    currentLastCoordinate,\n    closestNetworkCoordinate\n  }: {\n    currentLastCoordinate: Position;\n    closestNetworkCoordinate: Position;\n  }) {\n    const linestringRoute = this.routing.getRoute(currentLastCoordinate, closestNetworkCoordinate);\n\n    if (!linestringRoute) {\n      return;\n    }\n\n    if (!this.moveLineId) {\n      this.createMoveLine(linestringRoute.geometry.coordinates);\n    } else {\n      this.updateMoveLine(linestringRoute.geometry.coordinates);\n    }\n  }\n\n  private getMaxResults() {\n    const max = 1000;\n    const min = 10;\n    const onePercentOfPoints = Math.ceil(this.routing.getNodeCount() / 100);\n    const maxResults = Math.min(Math.max(onePercentOfPoints, min), max);\n    const maxDistance = Infinity;\n\n    return { maxResults, maxDistance };\n  }\n\n  private isClosestNetworkCoordinateNearPrevious(previousCoordinate: Position, closestNetworkCoordinate: Position): boolean {\n    // Get points near previous coordinate to see if closest network coordinate is close to previous coordinate\n    // If it is then we prefer a straight line to avoid doubling back on the route\n    const { maxResults, maxDistance } = this.getMaxResults();\n    const pointsGeoNearPreviousCoordinate = this.routing.getClosestNetworkCoordinates(previousCoordinate, maxResults, maxDistance)\n\n    const pointsNearPreviousCoordinate = pointsGeoNearPreviousCoordinate\n      .filter((coordinate) => {\n        return this.measureCoordinateToCoordinate(previousCoordinate, coordinate) <= this.pointerDistance;\n      });\n\n    const isCloseToPrevious = pointsNearPreviousCoordinate.some((coordinate) => {\n      const matching = coordinate[0] === closestNetworkCoordinate[0] &&\n        coordinate[1] === closestNetworkCoordinate[1];\n      return matching\n    });\n\n    return isCloseToPrevious;\n  }\n\n  private resolveFallbackRouteLine({\n    closestNetworkCoordinate,\n    routedLine,\n    straightLine,\n    forceStraightLine,\n  }: {\n    closestNetworkCoordinate: Position;\n    routedLine: Feature<LineString> | null;\n    straightLine: Feature<LineString>;\n    forceStraightLine: boolean;\n  }): { linestringRoute: Feature<LineString> | undefined; isStraightLine: boolean } {\n    // If the user has already committed to drawing off-network, keep drawing straight\n    // segments until a routed segment is committed (state flips on click).\n    if (forceStraightLine) {\n      return { linestringRoute: straightLine, isStraightLine: true };\n    }\n\n    // NOTE: We do not always fallback to a straight line because there may be times when a route cannot be generated\n    // because the network is disconnected (i.e. the nearest route network point is on a different connected component). \n    // In these cases drawing a straight line may be undesirable as it may cross the network which may be confusing to the user. \n\n    const previousCoordinate = straightLine.geometry.coordinates[0];\n\n    // If the closest network coordinate is already effectively \"at\" the previous\n    // coordinate, prefer a straight line to avoid doubling back.\n    const isCloseToPrevious = this.isClosestNetworkCoordinateNearPrevious(\n      previousCoordinate,\n      closestNetworkCoordinate\n    );\n\n    if (isCloseToPrevious) {\n      return { linestringRoute: straightLine, isStraightLine: true };\n    }\n\n    return { linestringRoute: routedLine ? routedLine : undefined, isStraightLine: false };\n  }\n\n  private updateRouteWithFallback({\n    event,\n    currentLastCoordinate,\n    closestNetworkCoordinate\n  }: {\n    event: TerraDrawMouseEvent;\n    currentLastCoordinate: Position;\n    closestNetworkCoordinate: Position;\n  }) {\n    const eventCoord: Position = [event.lng, event.lat];\n\n    const straightLine = this.getStraightLineString([currentLastCoordinate, eventCoord]);\n\n    const routedLine = this.routing.getRoute(\n      currentLastCoordinate,\n      closestNetworkCoordinate\n    );\n\n    const { linestringRoute } = this.resolveFallbackRouteLine({\n      closestNetworkCoordinate,\n      routedLine,\n      straightLine,\n      forceStraightLine: this.isDrawingStraightLine,\n    });\n\n    if (!linestringRoute) {\n      return;\n    }\n\n    if (!this.moveLineId) {\n      this.createMoveLine(linestringRoute.geometry.coordinates);\n    } else {\n      this.updateMoveLine(linestringRoute.geometry.coordinates);\n\n    }\n  }\n\n  private clickGetUpdateRoute({\n    fromCoordinate,\n    closestNetworkCoordinate,\n  }: {\n    fromCoordinate: Position;\n    closestNetworkCoordinate: Position;\n  }): { linestringRoute: Feature<LineString> | null; pointToCreate: Position } {\n    let routedLine = this.routing.getRoute(fromCoordinate, closestNetworkCoordinate);\n\n    return { linestringRoute: routedLine, pointToCreate: closestNetworkCoordinate };\n  }\n\n  private clickGetUpdateRouteWithFallback({\n    event,\n    fromCoordinate,\n    closestNetworkCoordinate,\n  }: {\n    event: TerraDrawMouseEvent;\n    fromCoordinate: Position;\n    closestNetworkCoordinate: Position;\n  }): {\n    linestringRoute: Feature<LineString> | undefined;\n    pointToCreate: Position;\n    isStraightLine: boolean;\n  } {\n    const eventCoord: Position = [event.lng, event.lat];\n\n    const straightLine = this.getStraightLineString([fromCoordinate, eventCoord]);\n\n    const routedLine = this.routing.getRoute(fromCoordinate, closestNetworkCoordinate);\n\n    const { linestringRoute, isStraightLine } = this.resolveFallbackRouteLine({\n      closestNetworkCoordinate,\n      routedLine,\n      straightLine,\n      forceStraightLine: this.isDrawingStraightLine,\n    });\n\n    const pointToCreate = isStraightLine ? eventCoord : closestNetworkCoordinate;\n\n    return { linestringRoute, pointToCreate, isStraightLine };\n  }\n\n  private createMoveLine(coordinates: Position[]) {\n    const [createdId] = this.store.create([\n      {\n        geometry: {\n          type: \"LineString\",\n          coordinates,\n        },\n        properties: this.getFeatureProperties(),\n      },\n    ]);\n\n    this.moveLineId = createdId;\n  }\n\n  private updateMoveLine(coordinates: Position[]) {\n    if (!this.moveLineId) {\n      return;\n    }\n\n    this.store.updateGeometry([\n      {\n        id: this.moveLineId,\n        geometry: {\n          type: \"LineString\",\n          coordinates,\n        },\n      },\n    ]);\n  }\n\n  private processCursorMove(event: TerraDrawMouseEvent) {\n    this.setCursor(this.cursors.draw);\n\n    if (this.moveLineId && !this.store.has(this.moveLineId)) {\n      this.moveLineId = undefined;\n    }\n\n    if (!this.currentId || this.currentCoordinate === 0) {\n      return;\n    }\n\n    if (!this.store.has(this.currentId)) {\n      this.currentId = undefined;\n      this.currentCoordinate = 0;\n      this.currentPointIds = [];\n      return;\n    }\n\n    const currentLineGeometry = this.store.getGeometryCopy<LineString>(\n      this.currentId\n    );\n\n    if (!currentLineGeometry) {\n      return;\n    }\n\n    const currentCoordinates = currentLineGeometry.coordinates;\n    const currentLength = currentCoordinates.length - 1;\n    const currentLastCoordinate = currentCoordinates[currentLength];\n    const canClose = this.measure(event, currentLastCoordinate) < this.pointerDistance;\n\n    // If the cursor is close to the last line closing coordinate\n    // delete the current moving line and set the cursor to pointer\n    if (canClose) {\n      this.setCursor(this.cursors.close);\n\n      if (!this.moveLineId) {\n        return;\n      }\n\n      if (this.store.has(this.moveLineId)) {\n        this.store.delete([this.moveLineId]);\n      }\n\n      this.moveLineId = undefined;\n      return;\n    }\n\n    const eventCoord: Position = [event.lng, event.lat];\n\n    const closestNetworkCoordinate = this.routing.getClosestNetworkCoordinate(eventCoord);\n\n    if (!closestNetworkCoordinate) {\n      return;\n    }\n\n    if (this.straightLineFallback) {\n      this.updateRouteWithFallback({\n        event,\n        currentLastCoordinate,\n        closestNetworkCoordinate\n      });\n    } else {\n      this.updateRoute({\n        currentLastCoordinate,\n        closestNetworkCoordinate\n      });\n    }\n\n  }\n\n  /** @internal */\n  registerBehaviors(config: BehaviorConfig) { }\n\n  /** @internal */\n  start() {\n    this.setStarted();\n    this.setCursor(this.cursors.draw);\n  }\n\n  /** @internal */\n  stop() {\n    this.cleanUp();\n    this.setStopped();\n    this.setCursor(\"unset\");\n  }\n\n  /** @internal */\n  onMouseMove(event: TerraDrawMouseEvent) {\n    this.latestMouseMoveEvent = event;\n\n    requestAnimationFrame(() => {\n      const latestEvent = this.latestMouseMoveEvent;\n      if (latestEvent) {\n        this.processCursorMove(latestEvent);\n        this.latestMouseMoveEvent = null;\n      }\n    });\n  }\n\n  /** @internal */\n  onClick(event: TerraDrawMouseEvent) {\n    if (event.button === \"right\") {\n      return;\n    }\n\n    const eventCoord = [event.lng, event.lat] as Position;\n\n    if (this.currentId && !this.store.has(this.currentId)) {\n      this.currentId = undefined;\n      this.currentCoordinate = 0;\n      this.currentPointIds = [];\n      this.isDrawingStraightLine = false;\n    }\n\n    if (this.currentId) {\n      const currentLineGeometry = this.store.getGeometryCopy<LineString>(\n        this.currentId\n      );\n\n      const currentCoordinates = currentLineGeometry.coordinates;\n      const currentLastCoordinate = currentCoordinates[currentCoordinates.length - 1];\n      const canClose = this.measure(event, currentLastCoordinate) < this.pointerDistance;\n\n      if (canClose) {\n        this.finish();\n        return;\n      }\n    } else {\n      // Only increment when we're about to start a new route. We roll this back\n      // if the user cancels the route via cleanUp.\n      this.routeId++;\n      this.didIncrementRouteIdForCurrentRoute = true;\n\n      // New route starts on-network by definition (first click snaps), so reset.\n      this.isDrawingStraightLine = false;\n    }\n\n    const closestPoint = this.routing.getClosestNetworkCoordinate(eventCoord);\n\n    if (this.currentCoordinate === 0 && closestPoint) {\n      const [createdId, pointId] = this.store.create([\n        {\n          geometry: {\n            type: \"LineString\",\n            coordinates: [closestPoint],\n          },\n          properties: this.getFeatureProperties(),\n        },\n        {\n          geometry: {\n            type: \"Point\",\n            coordinates: closestPoint,\n          },\n          properties: this.getFeatureProperties(),\n        },\n      ]);\n\n      this.currentId = createdId;\n      this.currentPointIds.push(pointId);\n      this.currentCoordinate++;\n\n      if (this.state === \"started\") {\n        this.setDrawing();\n      }\n    } else if (this.currentCoordinate === 1 && this.currentId && closestPoint) {\n      const currentLineGeometry = this.store.getGeometryCopy<LineString>(\n        this.currentId\n      );\n      const firstCoordinate = currentLineGeometry.coordinates[0];\n\n      const clickRoute = this.straightLineFallback\n        ? this.clickGetUpdateRouteWithFallback({\n          event,\n          fromCoordinate: firstCoordinate,\n          closestNetworkCoordinate: closestPoint,\n        })\n        : this.clickGetUpdateRoute({\n          fromCoordinate: firstCoordinate,\n          closestNetworkCoordinate: closestPoint,\n        });\n\n      if (clickRoute && clickRoute.linestringRoute) {\n        this.store.updateGeometry([\n          {\n            id: this.currentId,\n            geometry: clickRoute.linestringRoute.geometry,\n          },\n        ]);\n\n        // Commit straight-line mode state (only when fallback is enabled)\n        this.isDrawingStraightLine =\n          this.straightLineFallback && clickRoute && \"isStraightLine\" in clickRoute\n            ? clickRoute.isStraightLine\n            : false;\n\n        const pointId = this.createRoutePoint(clickRoute.pointToCreate);\n\n        this.currentCoordinate = 2;\n        this.currentPointIds.push(pointId);\n\n        // Handle the edge-case where maxPoints is 2.\n        if (this.currentCoordinate >= this.maxPoints) {\n          this.finish();\n        }\n      }\n    } else if (\n      this.currentCoordinate > 1 &&\n      this.currentId &&\n      closestPoint &&\n      this.currentCoordinate < this.maxPoints\n    ) {\n      const currentLineGeometry = this.store.getGeometryCopy<LineString>(\n        this.currentId\n      );\n\n      const currentLength = currentLineGeometry.coordinates.length - 1;\n      const currentLastCoordinate = currentLineGeometry.coordinates[currentLength];\n\n      const clickRoute = this.straightLineFallback\n        ? this.clickGetUpdateRouteWithFallback({\n          event,\n          fromCoordinate: currentLastCoordinate,\n          closestNetworkCoordinate: closestPoint,\n        })\n        : this.clickGetUpdateRoute({\n          fromCoordinate: currentLastCoordinate,\n          closestNetworkCoordinate: closestPoint,\n        });\n\n      if (clickRoute && clickRoute.linestringRoute) {\n        const newGeometry = {\n          ...currentLineGeometry,\n          coordinates: [\n            ...currentLineGeometry.coordinates,\n            ...clickRoute.linestringRoute.geometry.coordinates.slice(1),\n          ],\n        };\n\n        this.store.updateGeometry([\n          {\n            id: this.currentId,\n            geometry: newGeometry,\n          },\n        ]);\n\n        // Commit straight-line mode state (only when fallback is enabled)\n        this.isDrawingStraightLine =\n          this.straightLineFallback && clickRoute && \"isStraightLine\" in clickRoute\n            ? clickRoute.isStraightLine\n            : false;\n\n        // If adding another point would exceed maxPoints, finish immediately.\n        // At this stage we already have `currentCoordinate` route points.\n        if (this.currentCoordinate + 1 > this.maxPoints) {\n          this.finish();\n        } else {\n          const pointId = this.createRoutePoint(clickRoute.pointToCreate);\n\n          this.currentCoordinate++;\n          this.currentPointIds.push(pointId);\n\n          if (this.currentCoordinate === this.maxPoints) {\n            this.finish();\n          }\n        }\n      }\n    }\n  }\n\n  /** @internal */\n  onKeyDown() { }\n\n  /** @internal */\n  onKeyUp(event: TerraDrawKeyboardEvent) {\n    if (event.key === this.keyEvents.cancel) {\n      this.cleanUp();\n    }\n\n    if (event.key === this.keyEvents.finish) {\n      this.finish();\n    }\n  }\n\n  /** @internal */\n  onDragStart() { }\n\n  /** @internal */\n  onDrag() { }\n\n  /** @internal */\n  onDragEnd() { }\n\n  /** @internal */\n  cleanUp() {\n    if (!this.store) {\n      return;\n    }\n    const present = [this.currentId, this.moveLineId, ...this.currentPointIds].filter(id => id && this.store.has(id)) as string[];\n\n    this.store.delete(present);\n\n    this.currentId = undefined;\n    this.moveLineId = undefined;\n    this.currentPointIds = [];\n    this.currentCoordinate = 0;\n    this.isDrawingStraightLine = false;\n\n    // If the current route was never finished and we incremented the routeId on\n    // start, roll it back so cancelled routes don't consume ids.\n    if (this.didIncrementRouteIdForCurrentRoute) {\n      this.routeId = Math.max(0, this.routeId - 1);\n      this.didIncrementRouteIdForCurrentRoute = false;\n    }\n\n    if (this.state === \"drawing\") {\n      this.setStarted();\n    }\n  }\n\n  /** @internal */\n  styleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n    const styles = TerraDrawExtend.getDefaultStyling();\n\n    if (\n      feature.type === \"Feature\" &&\n      feature.geometry.type === \"LineString\" &&\n      feature.properties.mode === this.mode\n    ) {\n      styles.lineStringColor = this.getHexColorStylingValue(this.styles.lineStringColor, \"#B90E0A\", feature);\n      styles.lineStringWidth = this.getNumericStylingValue(this.styles.lineStringWidth, 4, feature);\n      styles.zIndex = 10;\n\n      return styles;\n    } else if (\n      feature.type === \"Feature\" &&\n      feature.geometry.type === \"Point\" &&\n      feature.properties.mode === this.mode\n    ) {\n      styles.pointColor = this.getHexColorStylingValue(this.styles.routePointColor, \"#B90E0A\", feature);\n      styles.pointOutlineColor = this.getHexColorStylingValue(this.styles.routePointOutlineColor, \"#B90E0A\", feature);\n      styles.pointOutlineWidth = this.getNumericStylingValue(this.styles.routePointOutlineWidth, 1, feature);\n\n      return styles;\n    }\n\n    return styles;\n  }\n\n  validateFeature(feature: unknown): ReturnType<Validation> {\n    return super.validateFeature(feature)\n  }\n\n  afterFeatureAdded(feature: GeoJSONStoreFeatures) { }\n\n}\n\nexport { Routing, type RouteFinder, type RoutingInterface } from \"./routing\";"],"names":["ARRAY_TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","KDBush","numItems","nodeSize","ArrayType","data","ids","this","coords","_pos","_finished","IndexArrayType","isNaN","Error","Math","min","max","arrayTypeIndex","indexOf","coordsByteSize","BYTES_PER_ELEMENT","idsByteSize","padCoords","ArrayBuffer","set","_proto","prototype","add","x","y","index","finish","numAdded","sort","left","right","axis","m","select","k","n","z","log","s","exp","sd","sqrt","floor","t","i","j","swapItem","swap","arr","tmp","TinyQueue","compare","a","b","length","_down","push","item","_up","pop","top","bottom","peek","pos","parent","current","halfLength","bestChild","rad","PI","around","lng","lat","maxResults","maxDistance","Infinity","maxHaverSinDist","result","undefined","haverSin","q","compareDist","node","dist","minLng","minLat","maxLng","maxLat","cosLat","cos","id","haverSinDist","midLng","midLat","nextAxis","leftNode","rightNode","boxDist","candidate","haverSinDLng","extremumLat","cosDLng","atan","tan","vertexLat","haverSinDistPartial","theta","sin","cosLat1","lat1","lat2","lng1","lng2","Routing","options","useCache","indexedNetworkPoints","points","routeFinder","network","routeCache","clone","initialise","_this","features","forEach","feature","geometry","coordinates","coordinate","getNodeCount","getClosestNetworkCoordinate","inputCoordinate","aroundInput","getClosestNetworkCoordinates","_this2","nearestCoordinates","setRouteFinder","setNetwork","expandRouteNetwork","additionalNetwork","clonedNetwork","expandNetwork","mergedNetwork","type","concat","getRoute","startCoord","endCoord","routeKey","route","properties","JSON","parse","stringify","defaultKeyEvents","cancel","defaultCursors","draw","close","TerraDrawRouteSnapMode","_TerraDrawBaseDrawMod","call","mode","currentCoordinate","currentId","keyEvents","cursors","maxPoints","moveLineId","routing","currentPointIds","routeId","latestMouseMoveEvent","straightLineFallback","isDrawingStraightLine","didIncrementRouteIdForCurrentRoute","pixelDistance","pointOne","pointTwo","deltaX","deltaY","updateOptions","cleanUp","_extends","measure","clickEvent","secondCoordinate","_this$project","project","containerX","containerY","measureCoordinateToCoordinate","coordinateOne","coordinateTwo","_this$project2","button","heldKeys","state","setStarted","deletable","filter","Boolean","store","has","getFeatureProperties","isDrawnRoute","getStraightLineString","createRoutePoint","position","create","updateRoute","_ref","linestringRoute","currentLastCoordinate","closestNetworkCoordinate","updateMoveLine","createMoveLine","getMaxResults","onePercentOfPoints","ceil","isClosestNetworkCoordinateNearPrevious","previousCoordinate","_this3","_this$getMaxResults","pointerDistance","some","resolveFallbackRouteLine","_ref2","routedLine","straightLine","forceStraightLine","isStraightLine","updateRouteWithFallback","_ref3","event","clickGetUpdateRoute","_ref4","fromCoordinate","pointToCreate","clickGetUpdateRouteWithFallback","_ref5","eventCoord","_this$resolveFallback2","_this$store$create2","updateGeometry","processCursorMove","setCursor","currentLineGeometry","getGeometryCopy","currentCoordinates","registerBehaviors","config","start","stop","setStopped","onMouseMove","_this4","requestAnimationFrame","latestEvent","onClick","closestPoint","_this$store$create3","pointId","setDrawing","firstCoordinate","clickRoute","newGeometry","slice","onKeyDown","onKeyUp","key","onDragStart","onDrag","onDragEnd","_this5","present","styleFeature","styles","TerraDrawExtend","getDefaultStyling","lineStringColor","getHexColorStylingValue","lineStringWidth","getNumericStylingValue","zIndex","pointColor","routePointColor","pointOutlineColor","routePointOutlineColor","pointOutlineWidth","routePointOutlineWidth","validateFeature","afterFeatureAdded","TerraDrawBaseDrawMode"],"mappings":"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"}