import{TerraDrawExtend as t}from"terra-draw";function e(){return e=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var s in i)({}).hasOwnProperty.call(i,s)&&(t[s]=i[s])}return t},e.apply(null,arguments)}const i=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class s{constructor(t,e=64,s=Float64Array,r){if(this.data=void 0,this.ids=void 0,this.coords=void 0,this._pos=void 0,this._finished=void 0,this.numItems=void 0,this.nodeSize=void 0,this.ArrayType=void 0,this.IndexArrayType=void 0,isNaN(t)||t<0)throw new Error(`Unexpected numItems value: ${t}.`);this.numItems=t,this.nodeSize=Math.min(Math.max(e,2),65535),this.ArrayType=s,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const o=i.indexOf(this.ArrayType),n=2*t*this.ArrayType.BYTES_PER_ELEMENT,h=t*this.IndexArrayType.BYTES_PER_ELEMENT,a=(8-h%8)%8;if(o<0)throw new Error(`Unexpected typed array class: ${s}.`);r?(this.data=r,this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+h+a,2*t),this._pos=2*t,this._finished=!0):(this.data=new ArrayBuffer(8+n+h+a),this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+h+a,2*t),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+o]),new Uint16Array(this.data,2,1)[0]=this.nodeSize,new Uint32Array(this.data,4,1)[0]=this.numItems)}add(t,e){const i=this._pos>>1;return this.ids[i]=i,this.coords[this._pos++]=t,this.coords[this._pos++]=e,i}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return r(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}}function r(t,e,i,s,n,h){if(n-s<=i)return;const a=s+n>>1;o(t,e,a,s,n,h),r(t,e,i,s,a-1,1-h),r(t,e,i,a+1,n,1-h)}function o(t,e,i,s,r,h){for(;r>s;){if(r-s>600){const n=r-s+1,a=i-s+1,d=Math.log(n),u=.5*Math.exp(2*d/3),c=.5*Math.sqrt(d*u*(n-u)/n)*(a-n/2<0?-1:1);o(t,e,i,Math.max(s,Math.floor(i-a*u/n+c)),Math.min(r,Math.floor(i+(n-a)*u/n+c)),h)}const a=e[2*i+h];let d=s,u=r;for(n(t,e,s,i),e[2*r+h]>a&&n(t,e,s,r);d<u;){for(n(t,e,d,u),d++,u--;e[2*d+h]<a;)d++;for(;e[2*u+h]>a;)u--}e[2*s+h]===a?n(t,e,s,u):(u++,n(t,e,u,r)),u<=i&&(s=u+1),i<=u&&(r=u-1)}}function n(t,e,i,s){h(t,i,s),h(e,2*i,2*s),h(e,2*i+1,2*s+1)}function h(t,e,i){const s=t[e];t[e]=t[i],t[i]=s}class a{constructor(t=[],e=(t,e)=>t<e?-1:t>e?1:0){if(this.data=void 0,this.length=void 0,this.compare=void 0,this.data=t,this.length=this.data.length,this.compare=e,this.length>0)for(let t=(this.length>>1)-1;t>=0;t--)this._down(t)}push(t){this.data.push(t),this._up(this.length++)}pop(){if(0===this.length)return;const t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}peek(){return this.data[0]}_up(t){const{data:e,compare:i}=this,s=e[t];for(;t>0;){const r=t-1>>1,o=e[r];if(i(s,o)>=0)break;e[t]=o,t=r}e[t]=s}_down(t){const{data:e,compare:i}=this,s=this.length>>1,r=e[t];for(;t<s;){let s=1+(t<<1);const o=s+1;if(o<this.length&&i(e[o],e[s])<0&&(s=o),i(e[s],r)>=0)break;e[t]=e[s],t=s}e[t]=r}}const d=Math.PI/180;function u(t,e,i,s){const r=s.minLng,o=s.maxLng,n=s.minLat,h=s.maxLat;if(t>=r&&t<=o)return e<n?l((e-n)*d):e>h?l((e-h)*d):0;const a=Math.min(l((t-r)*d),l((t-o)*d)),u=function(t,e){const i=1-2*e;return i<=0?t>0?90:-90:Math.atan(Math.tan(t*d)/i)/d}(e,a);return u>n&&u<h?p(a,i,e,u):Math.min(p(a,i,e,n),p(a,i,e,h))}function c(t,e){return t.dist-e.dist}function l(t){const e=Math.sin(t/2);return e*e}function p(t,e,i,s){return e*Math.cos(s*d)*t+l((i-s)*d)}function m(t,e,i,s,r){return p(l((t-i)*d),r,e,s)}class y{constructor(t){this.useCache=!0,this.indexedNetworkPoints=void 0,this.points=[],this.routeFinder=void 0,this.network=void 0,this.routeCache={},this.useCache=void 0===t.useCache||t.useCache,this.network=this.clone(t.network),this.routeFinder=t.routeFinder,this.initialise()}initialise(){this.network.features.forEach(t=>{t.geometry.coordinates.forEach(t=>{this.points.push(t)})}),this.indexedNetworkPoints=new s(this.points.length),this.points.forEach(t=>{this.indexedNetworkPoints.add(t[0],t[1])}),this.indexedNetworkPoints.finish(),this.routeCache={}}getClosestNetworkCoordinate(t){const e=function(t,e,i,s=Infinity,r=Infinity){let o=1;const n=[];void 0===s&&(s=Infinity),void 0!==r&&(o=l(r/6371));const h=new a([],c);let p={left:0,right:t.ids.length-1,axis:0,dist:0,minLng:-180,minLat:-90,maxLng:180,maxLat:90};const y=Math.cos(i*d);for(;p;){const r=p.right,a=p.left;if(r-a<=t.nodeSize)for(let s=a;s<=r;s++){const r=t.ids[s],o=m(e,i,t.coords[2*s],t.coords[2*s+1],y);h.push({id:r,dist:o})}else{const s=a+r>>1,o=t.coords[2*s],n=t.coords[2*s+1],d=t.ids[s],c=m(e,i,o,n,y);h.push({id:d,dist:c});const l=(p.axis+1)%2,g={left:a,right:s-1,axis:l,minLng:p.minLng,minLat:p.minLat,maxLng:0===p.axis?o:p.maxLng,maxLat:1===p.axis?n:p.maxLat,dist:0},f={left:s+1,right:r,axis:l,minLng:0===p.axis?o:p.minLng,minLat:1===p.axis?n:p.minLat,maxLng:p.maxLng,maxLat:p.maxLat,dist:0};g.dist=u(e,i,y,g),f.dist=u(e,i,y,f),h.push(g),h.push(f)}for(;h.length&&null!=h.peek().id;){const t=h.pop();if(t.dist>o)return n;if(n.push(t.id),n.length===s)return n}p=h.pop()}return n}(this.indexedNetworkPoints,t[0],t[1],1);return this.points[e[0]]||null}setRouteFinder(t){this.routeFinder=t}setNetwork(t){this.network=this.clone(t),this.routeFinder.setNetwork(t),this.initialise()}expandRouteNetwork(t){const e=this.clone(t);this.routeFinder.expandNetwork(e);const i={type:"FeatureCollection",features:[...e.features,...this.network.features]};this.network=i,this.initialise()}getRoute(t,e){if(this.useCache){const i=`${t}-${e}`;if(i in this.routeCache)return this.routeCache[i]}const i=this.routeFinder.getRoute({type:"Feature",geometry:{type:"Point",coordinates:t},properties:{}},{type:"Feature",geometry:{type:"Point",coordinates:e},properties:{}});return this.useCache?(this.routeCache[`${t}-${e}`]=i,i):i}clone(t){return JSON.parse(JSON.stringify(t))}}const g={cancel:"Escape",finish:"Enter"},f={draw:"crosshair",close:"pointer"},{TerraDrawBaseDrawMode:I}=t;class v extends I{constructor(t){super(t,!0),this.mode="routesnap",this.currentCoordinate=0,this.currentId=void 0,this.keyEvents=g,this.cursors=f,this.maxPoints=2,this.moveLineId=void 0,this.routing=void 0,this.currentPointIds=[],this.routeId=0,this.latestMouseMoveEvent=null,this.didIncrementRouteIdForCurrentRoute=!1,this.pixelDistance=(t,e)=>{const{x:i,y:s}=t,{x:r,y:o}=e,n=r-i,h=o-s;return Math.sqrt(n*n+h*h)},this.updateOptions(t)}updateOptions(t){super.updateOptions(t),null!=t&&t.routing&&t.routing!==this.routing&&(this.cleanUp(),this.routing=t.routing),void 0!==(null==t?void 0:t.maxPoints)&&t.maxPoints!==this.maxPoints&&t.maxPoints>=2&&(this.maxPoints=t.maxPoints),null!=t&&t.cursors&&(this.cursors=e({},this.cursors,t.cursors)),null===(null==t?void 0:t.keyEvents)?this.keyEvents={cancel:null,finish:null}:null!=t&&t.keyEvents&&(this.keyEvents=e({},this.keyEvents,t.keyEvents))}measure(t,e){const{x:i,y:s}=this.project(e[0],e[1]);return this.pixelDistance({x:i,y:s},{x:t.containerX,y:t.containerY})}close(){this.currentId&&(this.currentCoordinate=0,this.currentId=void 0,this.currentPointIds=[],"drawing"===this.state&&this.setStarted())}finish(){if(!this.currentId)return;this.didIncrementRouteIdForCurrentRoute=!1;const t=[this.moveLineId,...this.currentPointIds].filter(t=>Boolean(t)&&this.store.has(t));t.length&&this.store.delete(t),this.close()}getFeatureProperties(){return{mode:this.mode,isDrawnRoute:!0,routeId:this.routeId}}createRoutePoint(t){const[e]=this.store.create([{geometry:{type:"Point",coordinates:t},properties:this.getFeatureProperties()}]);return e}processCursorMove(t){if(this.setCursor(this.cursors.draw),this.moveLineId&&!this.store.has(this.moveLineId)&&(this.moveLineId=void 0),!this.currentId||0===this.currentCoordinate)return;const e=this.store.getGeometryCopy(this.currentId);if(!e)return;const i=e.coordinates,s=i[i.length-1];if(this.measure(t,s)<this.pointerDistance){if(this.setCursor(this.cursors.close),!this.moveLineId)return;return this.store.has(this.moveLineId)&&this.store.delete([this.moveLineId]),void(this.moveLineId=void 0)}const r=this.routing.getClosestNetworkCoordinate([t.lng,t.lat]);if(!r)return;const o=this.routing.getRoute(s,r);if(o)if(this.moveLineId)this.store.updateGeometry([{id:this.moveLineId,geometry:o.geometry}]);else{const[t]=this.store.create([{geometry:o.geometry,properties:this.getFeatureProperties()}]);this.moveLineId=t}}registerBehaviors(t){}start(){this.setStarted(),this.setCursor(this.cursors.draw)}stop(){this.cleanUp(),this.setStopped(),this.setCursor("unset")}onMouseMove(t){this.latestMouseMoveEvent=t,requestAnimationFrame(()=>{const t=this.latestMouseMoveEvent;t&&(this.processCursorMove(t),this.latestMouseMoveEvent=null)})}onClick(t){if("right"===t.button)return;const i=[t.lng,t.lat];if(this.currentId&&!this.store.has(this.currentId)&&(this.currentId=void 0,this.currentCoordinate=0,this.currentPointIds=[]),this.currentId){const e=this.store.getGeometryCopy(this.currentId).coordinates;if(this.measure(t,e[e.length-1])<this.pointerDistance)return void this.finish()}else this.routeId++,this.didIncrementRouteIdForCurrentRoute=!0;const s=this.routing.getClosestNetworkCoordinate(i);if(0===this.currentCoordinate&&s){const[t,e]=this.store.create([{geometry:{type:"LineString",coordinates:[s]},properties:this.getFeatureProperties()},{geometry:{type:"Point",coordinates:s},properties:this.getFeatureProperties()}]);this.currentId=t,this.currentPointIds.push(e),this.currentCoordinate++,"started"===this.state&&this.setDrawing()}else if(1===this.currentCoordinate&&this.currentId&&s){const t=this.store.getGeometryCopy(this.currentId),e=this.routing.getRoute(t.coordinates[0],s);if(e){this.store.updateGeometry([{id:this.currentId,geometry:null==e?void 0:e.geometry}]);const t=this.createRoutePoint(s);this.currentCoordinate=2,this.currentPointIds.push(t),this.currentCoordinate>=this.maxPoints&&this.finish()}}else if(this.currentCoordinate>1&&this.currentId&&s&&this.currentCoordinate<this.maxPoints){const t=this.store.getGeometryCopy(this.currentId),i=this.routing.getRoute(t.coordinates[t.coordinates.length-1],s);if(i){const r=e({},t,{coordinates:[...t.coordinates,...i.geometry.coordinates.slice(1)]});if(this.store.updateGeometry([{id:this.currentId,geometry:r}]),this.currentCoordinate+1>this.maxPoints)this.finish();else{const t=this.createRoutePoint(s);this.currentCoordinate++,this.currentPointIds.push(t),this.currentCoordinate===this.maxPoints&&this.finish()}}}}onKeyDown(){}onKeyUp(t){t.key===this.keyEvents.cancel&&this.cleanUp(),t.key===this.keyEvents.finish&&this.finish()}onDragStart(){}onDrag(){}onDragEnd(){}cleanUp(){if(!this.store)return;const t=[this.currentId,this.moveLineId,...this.currentPointIds].filter(t=>t&&this.store.has(t));this.store.delete(t),this.currentId=void 0,this.moveLineId=void 0,this.currentPointIds=[],this.currentCoordinate=0,this.didIncrementRouteIdForCurrentRoute&&(this.routeId=Math.max(0,this.routeId-1),this.didIncrementRouteIdForCurrentRoute=!1),"drawing"===this.state&&this.setStarted()}styleFeature(e){const i=t.getDefaultStyling();return"Feature"===e.type&&"LineString"===e.geometry.type&&e.properties.mode===this.mode?(i.lineStringColor=this.getHexColorStylingValue(this.styles.lineStringColor,"#B90E0A",e),i.lineStringWidth=this.getNumericStylingValue(this.styles.lineStringWidth,4,e),i.zIndex=10,i):"Feature"===e.type&&"Point"===e.geometry.type&&e.properties.mode===this.mode?(i.pointColor=this.getHexColorStylingValue(this.styles.routePointColor,"#B90E0A",e),i.pointOutlineColor=this.getHexColorStylingValue(this.styles.routePointOutlineColor,"#B90E0A",e),i.pointOutlineWidth=this.getNumericStylingValue(this.styles.routePointOutlineWidth,1,e),i):i}validateFeature(t){return super.validateFeature(t)}afterFeatureAdded(t){}}export{y as Routing,v as TerraDrawRouteSnapMode};
//# sourceMappingURL=terra-draw-route-snap-mode.modern.js.map
