{"version":3,"file":"terra-draw-route-snap-mode.modern.js","sources":["../src/kdbush/kdbush.ts","../src/kdbush/tinyqueue.ts","../src/kdbush/geokdbush.ts","../src/routing.ts","../src/terra-draw-route-snap-mode.ts"],"sourcesContent":["// Adapted from https://github.com/mourner/kdbush\n\n// ISC License\n\n// Copyright (c) 2018, Vladimir Agafonkin\n\n// Permission to use, copy, modify, and/or distribute this software for any purpose\n// with or without fee is hereby granted, provided that the above copyright notice\n// and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n// FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n// OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n// THIS SOFTWARE.\n\nconst ARRAY_TYPES = [\n    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array\n];\n\nconst VERSION = 1;\nconst HEADER_SIZE = 8;\n\nexport class KDBush {\n    private data: ArrayBuffer;\n    public ids: Uint16Array | Uint32Array;\n    public coords: InstanceType<TypedArrayConstructor>;\n    private _pos: number;\n    private _finished: boolean;\n    private numItems: number;\n    public nodeSize: number;\n    private ArrayType: TypedArrayConstructor;\n    private IndexArrayType: typeof Uint16Array | typeof Uint32Array;\n\n    constructor(\n        numItems: number,\n        nodeSize: number = 64,\n        ArrayType: TypedArrayConstructor = Float64Array,\n        data?: ArrayBuffer\n    ) {\n        if (isNaN(numItems) || numItems < 0) {\n            throw new Error(`Unexpected numItems value: ${numItems}.`);\n        }\n\n        this.numItems = numItems;\n        this.nodeSize = Math.min(Math.max(nodeSize, 2), 65535);\n        this.ArrayType = ArrayType;\n        this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;\n\n        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n        const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;\n        const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;\n        const padCoords = (8 - idsByteSize % 8) % 8;\n\n        if (arrayTypeIndex < 0) {\n            throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n        }\n\n        if (data) {\n            this.data = data;\n            this.ids = new (this.IndexArrayType as any)(this.data, HEADER_SIZE, numItems);\n            this.coords = new (this.ArrayType as any)(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = numItems * 2;\n            this._finished = true;\n        } else {\n            this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);\n            this.ids = new (this.IndexArrayType as any)(this.data, HEADER_SIZE, numItems);\n            this.coords = new (this.ArrayType as any)(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = 0;\n            this._finished = false;\n\n            new Uint8Array(this.data, 0, 2).set([0xdb, (VERSION << 4) + arrayTypeIndex]);\n            new Uint16Array(this.data, 2, 1)[0] = this.nodeSize;\n            new Uint32Array(this.data, 4, 1)[0] = this.numItems;\n        }\n    }\n\n    add(x: number, y: number): number {\n        const index = this._pos >> 1;\n        this.ids[index] = index;\n        this.coords[this._pos++] = x;\n        this.coords[this._pos++] = y;\n        return index;\n    }\n\n    finish(): this {\n        const numAdded = this._pos >> 1;\n        if (numAdded !== this.numItems) {\n            throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);\n        }\n        sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);\n        this._finished = true;\n        return this;\n    }\n}\n\ntype TypedArrayConstructor =\n    Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor |\n    Int16ArrayConstructor | Uint16ArrayConstructor |\n    Int32ArrayConstructor | Uint32ArrayConstructor |\n    Float32ArrayConstructor | Float64ArrayConstructor;\n\nfunction sort(\n    ids: Uint16Array | Uint32Array,\n    coords: InstanceType<TypedArrayConstructor>,\n    nodeSize: number,\n    left: number,\n    right: number,\n    axis: number\n): void {\n    if (right - left <= nodeSize) return;\n    const m = (left + right) >> 1;\n    select(ids, coords, m, left, right, axis);\n    sort(ids, coords, nodeSize, left, m - 1, 1 - axis);\n    sort(ids, coords, nodeSize, m + 1, right, 1 - axis);\n}\n\nfunction select(\n    ids: Uint16Array | Uint32Array,\n    coords: InstanceType<TypedArrayConstructor>,\n    k: number,\n    left: number,\n    right: number,\n    axis: number\n): void {\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, axis);\n        }\n\n        const t = coords[2 * k + axis];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + axis] > t) {\n            swapItem(ids, coords, left, right);\n        }\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + axis] < t) i++;\n            while (coords[2 * j + axis] > t) j--;\n        }\n\n        if (coords[2 * left + axis] === t) {\n            swapItem(ids, coords, left, j);\n        } else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(\n    ids: Uint16Array | Uint32Array,\n    coords: InstanceType<TypedArrayConstructor>,\n    i: number,\n    j: number\n): void {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap<T extends Uint16Array | Uint32Array | Float32Array | Float64Array | Int8Array | Int16Array | Int32Array | Uint8Array | Uint8ClampedArray>(\n    arr: T,\n    i: number,\n    j: number\n): void {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","// Adapted from https://github.com/mourner/kdbush\n\n// ISC License\n\n// Copyright (c) 2017, Vladimir Agafonkin\n\n// Permission to use, copy, modify, and/or distribute this software for any purpose\n// with or without fee is hereby granted, provided that the above copyright notice\n// and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n// FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n// OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n// THIS SOFTWARE.\n\nexport default class TinyQueue<T> {\n\n    private data: T[];\n    public length: number;\n    private compare: (a: T, b: T) => number;\n\n    constructor(\n        data: T[] = [],\n        compare: (a: T, b: T) => number = (a, b) =>\n            a < b ? -1 : a > b ? 1 : 0\n    ) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) {\n                this._down(i);\n            }\n        }\n    }\n\n    push(item: T): void {\n        this.data.push(item);\n        this._up(this.length++);\n    }\n\n    pop(): T | undefined {\n        if (this.length === 0) {\n            return undefined;\n        }\n\n        const top = this.data[0];\n        const bottom = this.data.pop() as T;\n\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek(): T | undefined {\n        return this.data[0];\n    }\n\n    private _up(pos: number): void {\n        const { data, compare } = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) {\n                break;\n            }\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    private _down(pos: number): void {\n        const { data, compare } = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let bestChild = (pos << 1) + 1;\n            const right = bestChild + 1;\n\n            if (right < this.length && compare(data[right], data[bestChild]) < 0) {\n                bestChild = right;\n            }\n\n            if (compare(data[bestChild], item) >= 0) {\n                break;\n            }\n\n            data[pos] = data[bestChild];\n            pos = bestChild;\n        }\n\n        data[pos] = item;\n    }\n}\n","// Adapted from https://github.com/mourner/geokdbush\n\n// ISC License\n\n// Copyright (c) 2017, Vladimir Agafonkin\n\n// Permission to use, copy, modify, and/or distribute this software for any purpose\n// with or without fee is hereby granted, provided that the above copyright notice\n// and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n// FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n// OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n// THIS SOFTWARE.\n\nimport { KDBush } from './kdbush';\nimport TinyQueue from './tinyqueue';\n\nconst earthRadius = 6371;\nconst rad = Math.PI / 180;\n\n\nexport function around(index: KDBush, lng: number, lat: number, maxResults = Infinity, maxDistance = Infinity) {\n    let maxHaverSinDist = 1;\n    const result = [];\n\n    if (maxResults === undefined) maxResults = Infinity;\n    if (maxDistance !== undefined) maxHaverSinDist = haverSin(maxDistance / earthRadius);\n\n    // a distance-sorted priority queue that will contain both points and kd-tree nodes\n    const q = new TinyQueue([], compareDist);\n\n    // an object that represents the top kd-tree node (the whole Earth)\n    let node = {\n        left: 0, // left index in the kd-tree array\n        right: index.ids.length - 1, // right index\n        axis: 0, // 0 for longitude axis and 1 for latitude axis\n        dist: 0, // will hold the lower bound of children's distances to the query point\n        minLng: -180, // bounding box of the node\n        minLat: -90,\n        maxLng: 180,\n        maxLat: 90\n    };\n\n    const cosLat = Math.cos(lat * rad);\n\n    while (node) {\n        const right = node.right;\n        const left = node.left;\n\n        if (right - left <= index.nodeSize) { // leaf node\n\n            // add all points of the leaf node to the queue\n            for (let i = left; i <= right; i++) {\n                const id = index.ids[i];\n\n                const dist = haverSinDist(lng, lat, index.coords[2 * i], index.coords[2 * i + 1], cosLat);\n                q.push({ id, dist });\n            }\n\n        } else { // not a leaf node (has child nodes)\n\n            const m = (left + right) >> 1; // middle index\n            const midLng = index.coords[2 * m];\n            const midLat = index.coords[2 * m + 1];\n\n            // add middle point to the queue\n            const id = index.ids[m];\n            const dist = haverSinDist(lng, lat, midLng, midLat, cosLat);\n            q.push({ id, dist });\n\n\n            const nextAxis = (node.axis + 1) % 2;\n\n            // first half of the node\n            const leftNode = {\n                left,\n                right: m - 1,\n                axis: nextAxis,\n                minLng: node.minLng,\n                minLat: node.minLat,\n                maxLng: node.axis === 0 ? midLng : node.maxLng,\n                maxLat: node.axis === 1 ? midLat : node.maxLat,\n                dist: 0\n            };\n            // second half of the node\n            const rightNode = {\n                left: m + 1,\n                right,\n                axis: nextAxis,\n                minLng: node.axis === 0 ? midLng : node.minLng,\n                minLat: node.axis === 1 ? midLat : node.minLat,\n                maxLng: node.maxLng,\n                maxLat: node.maxLat,\n                dist: 0\n            };\n\n            leftNode.dist = boxDist(lng, lat, cosLat, leftNode);\n            rightNode.dist = boxDist(lng, lat, cosLat, rightNode);\n\n            // add child nodes to the queue\n            q.push(leftNode);\n            q.push(rightNode);\n        }\n\n        // fetch closest points from the queue; they're guaranteed to be closer\n        // than all remaining points (both individual and those in kd-tree nodes),\n        // since each node's distance is a lower bound of distances to its children\n        while (q.length && q.peek().id != null) {\n            const candidate = q.pop()!;\n            if (candidate.dist > maxHaverSinDist) return result;\n            result.push(candidate.id);\n            if (result.length === maxResults) return result;\n        }\n\n        // the next closest kd-tree node\n        node = q.pop();\n    }\n\n    return result;\n}\n\n// lower bound for distance from a location to points inside a bounding box\nfunction boxDist(lng: number, lat: number, cosLat: number, node: any) {\n    const minLng = node.minLng;\n    const maxLng = node.maxLng;\n    const minLat = node.minLat;\n    const maxLat = node.maxLat;\n\n    // query point is between minimum and maximum longitudes\n    if (lng >= minLng && lng <= maxLng) {\n        if (lat < minLat) return haverSin((lat - minLat) * rad);\n        if (lat > maxLat) return haverSin((lat - maxLat) * rad);\n        return 0;\n    }\n\n    // query point is west or east of the bounding box;\n    // calculate the extremum for great circle distance from query point to the closest longitude;\n    const haverSinDLng = Math.min(haverSin((lng - minLng) * rad), haverSin((lng - maxLng) * rad));\n    const extremumLat = vertexLat(lat, haverSinDLng);\n\n    // if extremum is inside the box, return the distance to it\n    if (extremumLat > minLat && extremumLat < maxLat) {\n        return haverSinDistPartial(haverSinDLng, cosLat, lat, extremumLat);\n    }\n    // otherwise return the distan e to one of the bbox corners (whichever is closest)\n    return Math.min(\n        haverSinDistPartial(haverSinDLng, cosLat, lat, minLat),\n        haverSinDistPartial(haverSinDLng, cosLat, lat, maxLat)\n    );\n}\n\nfunction compareDist(a: any, b: any) {\n    return a.dist - b.dist;\n}\n\nfunction haverSin(theta: number) {\n    const s = Math.sin(theta / 2);\n    return s * s;\n}\n\nfunction haverSinDistPartial(haverSinDLng: number, cosLat1: number, lat1: number, lat2: number) {\n    return cosLat1 * Math.cos(lat2 * rad) * haverSinDLng + haverSin((lat1 - lat2) * rad);\n}\n\nfunction haverSinDist(lng1: number, lat1: number, lng2: number, lat2: number, cosLat1: number) {\n    const haverSinDLng = haverSin((lng1 - lng2) * rad);\n    return haverSinDistPartial(haverSinDLng, cosLat1, lat1, lat2);\n}\n\nexport function distance(lng1: number, lat1: number, lng2: number, lat2: number) {\n    const h = haverSinDist(lng1, lat1, lng2, lat2, Math.cos(lat1 * rad));\n    return 2 * earthRadius * Math.asin(Math.sqrt(h));\n}\n\nfunction vertexLat(lat: number, haverSinDLng: number) {\n    const cosDLng = 1 - 2 * haverSinDLng;\n    if (cosDLng <= 0) return lat > 0 ? 90 : -90;\n    return Math.atan(Math.tan(lat * rad) / cosDLng) / rad;\n}","import { KDBush } from \"./kdbush/kdbush\";\nimport { around } from \"./kdbush/geokdbush\";\nimport {\n  FeatureCollection,\n  LineString,\n  Position,\n  Feature,\n  Point,\n} from \"geojson\";\n\nexport type RouteFinder = {\n  getRoute: (positionA: Feature<Point>, positionB: Feature<Point>) => Feature<LineString> | null\n  setNetwork: (network: FeatureCollection<LineString>) => void\n}\n\nexport interface RoutingInterface {\n  getRoute: (\n    startCoord: Position,\n    endCoord: Position\n  ) => Feature<LineString> | null;\n  getClosestNetworkCoordinate: (coordinate: Position) => Position | null;\n  setRouteFinder: (routeFinder: RouteFinder) => void;\n  setNetwork: (network: FeatureCollection<LineString>) => void\n}\n\n/**\n * Routing class for finding routes on a network of LineStrings.\n * The LineString network must have coordinates that are shared between\n * the LineStrings in order to find a route.\n */\nexport class Routing implements RoutingInterface {\n  constructor(options: {\n    network: FeatureCollection<LineString>, useCache?: boolean,\n    routeFinder: RouteFinder\n  }) {\n    this.useCache = options.useCache || true;\n    this.network = options.network;\n    this.routeFinder = options.routeFinder;\n\n    this.initialise();\n  }\n\n  private useCache: boolean = true;\n  private indexedNetworkPoints!: KDBush;\n  private points: Position[] = []\n  private routeFinder: RouteFinder;\n  private network: FeatureCollection<LineString>;\n  private routeCache: Record<string, Feature<LineString> | null> = {};\n\n  // Initialise the routing instance setting internal data structures\n  private initialise() {\n    this.network.features.forEach((feature) => {\n      feature.geometry.coordinates.forEach((coordinate) => {\n        this.points.push(coordinate);\n      });\n    });\n\n    this.indexedNetworkPoints = new KDBush(this.points.length);\n\n    this.points.forEach(coordinate => {\n      this.indexedNetworkPoints.add(coordinate[0], coordinate[1]);\n    })\n\n    this.indexedNetworkPoints.finish();\n\n    this.routeCache = {};\n  }\n\n  /**\n   * Return the closest network coordinate to the input coordinate\n   * @param inputCoordinate The coordinate to find the closest network coordinate to\n   * @returns a coordinate on the network or null if no coordinate is found\n   */\n  public getClosestNetworkCoordinate(inputCoordinate: Position) {\n    const aroundInput: number[] = around(\n      this.indexedNetworkPoints,\n      inputCoordinate[0],\n      inputCoordinate[1],\n      1\n    );\n\n    const nearest = this.points[aroundInput[0]]\n    return nearest ? nearest : null;\n  }\n\n  /**\n   * Set the route finder for the routing instance\n   * @param routeFinder The route finder to use\n   */\n  public setRouteFinder(routeFinder: RouteFinder) {\n    this.routeFinder = routeFinder;\n  }\n\n  /**\n   * Set the network for the routing instance\n   * @param network The network to use\n   */\n  public setNetwork(network: FeatureCollection<LineString>) {\n    this.network = network;\n\n    // Ensure the network is updated correctly for the router finder\n    this.routeFinder.setNetwork(network);\n\n    // Re-initialize all internal data structures for this class\n    this.initialise();\n  }\n\n  /**\n   * Get the route between two coordinates returned as a GeoJSON LineString\n   * @param startCoord start coordinate\n   * @param endCoord end coordinate\n   * @returns The route as a GeoJSON LineString\n   */\n  public getRoute(startCoord: Position, endCoord: Position): Feature<LineString> | null {\n\n    // Check if caching is enabled, and if the coordinates are already in the cache  \n    if (this.useCache) {\n      const routeKey = `${startCoord}-${endCoord}`;\n\n      if (this.routeCache[routeKey]) {\n        return this.routeCache[routeKey];\n      }\n    }\n\n    const start = {\n      type: \"Feature\",\n      geometry: {\n        type: \"Point\",\n        coordinates: startCoord,\n      },\n      properties: {},\n    } as Feature<Point>;\n\n    const end = {\n      type: \"Feature\",\n      geometry: {\n        type: \"Point\",\n        coordinates: endCoord,\n      },\n      properties: {},\n    } as Feature<Point>;\n\n    const route = this.routeFinder.getRoute(start, end);\n\n    // If caching is enabled, store the route in the cache\n    if (this.useCache) {\n      const routeKey = `${startCoord}-${endCoord}`\n      this.routeCache[routeKey] = route;\n      return route;\n    }\n\n    return route;\n\n  }\n}\n","import {\n  TerraDrawAdapterStyling,\n  TerraDrawKeyboardEvent,\n  TerraDrawMouseEvent,\n  BehaviorConfig,\n  GeoJSONStoreFeatures,\n  TerraDrawExtend\n} from \"terra-draw\";\nimport { LineString, Position } from \"geojson\";\nimport { Validation } from \"terra-draw/dist/common\";\nimport { RoutingInterface } from \"./routing\";\n\ntype TerraDrawLineStringModeKeyEvents = {\n  cancel: KeyboardEvent[\"key\"] | null;\n  finish: KeyboardEvent[\"key\"] | null;\n};\n\nconst defaultKeyEvents = { cancel: \"Escape\", finish: \"Enter\" };\n\ninterface Cursors {\n  draw?: TerraDrawExtend.Cursor;\n  close?: TerraDrawExtend.Cursor;\n}\n\nconst defaultCursors = {\n  draw: \"crosshair\",\n  close: \"pointer\"\n} as Required<Cursors>;\n\ntype RouteStyling = {\n  lineStringWidth: TerraDrawExtend.NumericStyling;\n  lineStringColor: TerraDrawExtend.HexColorStyling\n  routePointColor: TerraDrawExtend.HexColorStyling;\n  routePointWidth: TerraDrawExtend.NumericStyling;\n  routePointOutlineColor: TerraDrawExtend.HexColorStyling;\n  routePointOutlineWidth: TerraDrawExtend.NumericStyling;\n};\n\ninterface TerraDrawPolygonModeOptions<T extends TerraDrawExtend.CustomStyling>\n  extends TerraDrawExtend.BaseModeOptions<T> {\n  routing: RoutingInterface;\n  pointerDistance?: number;\n  keyEvents?: TerraDrawLineStringModeKeyEvents | null;\n  maxPoints?: number;\n  cursors?: Partial<Cursors>;\n}\n\nconst { TerraDrawBaseDrawMode } = TerraDrawExtend;\n\nexport class TerraDrawRouteSnapMode extends TerraDrawBaseDrawMode<RouteStyling> {\n  mode = \"routesnap\" as const;\n\n  private currentCoordinate = 0;\n  private currentId: string | undefined;\n  private keyEvents: TerraDrawLineStringModeKeyEvents = defaultKeyEvents;\n  private cursors: Required<Cursors> = defaultCursors;\n\n  private maxPoints: number = 1\n  private moveLineId: string | undefined;\n  private routing!: RoutingInterface;\n  private currentPointIds: string[] = [];\n  private routeId = 0;\n\n  constructor(options?: TerraDrawPolygonModeOptions<RouteStyling>) {\n    super(options, true);\n    this.updateOptions(options);\n  }\n\n  override updateOptions(options?: Partial<TerraDrawPolygonModeOptions<RouteStyling>>) {\n    super.updateOptions(options);\n\n    if (options?.routing && options.routing !== this.routing) {\n      // We can't guarantee the rout created so far is valid with the new routing \n      // So we need to clean up the current state\n      this.cleanUp();\n      this.routing = options.routing;\n    }\n\n    if (options?.maxPoints !== undefined && options.maxPoints !== this.maxPoints && options.maxPoints > 0) {\n      this.maxPoints = options.maxPoints;\n    }\n\n    if (options?.cursors) {\n      this.cursors = { ...this.cursors, ...options.cursors };\n    }\n\n    // null is the case where we want to explicitly turn key bindings off\n    if (options?.keyEvents === null) {\n      this.keyEvents = { cancel: null, finish: null };\n    } else if (options?.keyEvents) {\n      this.keyEvents = { ...this.keyEvents, ...options.keyEvents };\n    }\n  }\n\n  private pixelDistance = (\n    pointOne: { x: number; y: number },\n    pointTwo: { x: number; y: number }\n  ) => {\n    const { x: x1, y: y1 } = pointOne;\n    const { x: x2, y: y2 } = pointTwo;\n    const y = x2 - x1;\n    const x = y2 - y1;\n    return Math.sqrt(x * x + y * y);\n  };\n\n  private measure(clickEvent: TerraDrawMouseEvent, secondCoordinate: Position) {\n    const { x, y } = this.project(secondCoordinate[0], secondCoordinate[1]);\n\n    const distance = this.pixelDistance(\n      { x, y },\n      { x: clickEvent.containerX, y: clickEvent.containerY }\n    );\n\n    return distance;\n  }\n\n  private close() {\n    if (!this.currentId) {\n      return;\n    }\n\n    // Reset the state back to starting state\n    this.currentCoordinate = 0;\n    this.currentId = undefined;\n    this.currentPointIds = [];\n\n    // Go back to started state\n    if (this.state === \"drawing\") {\n      this.setStarted();\n    }\n  }\n\n  /** @internal */\n  registerBehaviors(config: BehaviorConfig) { }\n\n  /** @internal */\n  start() {\n    this.setStarted();\n    this.setCursor(this.cursors.draw);\n  }\n\n  /** @internal */\n  stop() {\n    this.cleanUp();\n    this.setStopped();\n    this.setCursor(\"unset\");\n  }\n\n\n  private latestEvent: TerraDrawMouseEvent | null = null;\n\n  /** @internal */\n  onMouseMove(event: TerraDrawMouseEvent) {\n    this.latestEvent = event;\n\n    requestAnimationFrame(() => {\n      const latestEvent = this.latestEvent;\n      if (latestEvent) {\n        this.processMouseMove(latestEvent);\n        this.latestEvent = null;\n      }\n    });\n  }\n\n  private processMouseMove(event: TerraDrawMouseEvent) {\n    this.setCursor(this.cursors.draw);\n\n    if (this.moveLineId && !this.store.has(this.moveLineId)) {\n      this.moveLineId = undefined;\n    }\n\n    if (!this.currentId || this.currentCoordinate === 0) {\n      return;\n    }\n\n    const currentLineGeometryForCloseCheck = this.store.getGeometryCopy<LineString>(\n      this.currentId\n    );\n\n    if (!currentLineGeometryForCloseCheck) {\n      return;\n    }\n\n    // If the cursor is close the last line\n    // delete the current moving line and set the cursor to pointer\n    if (\n      this.measure(\n        event,\n        currentLineGeometryForCloseCheck.coordinates[\n        currentLineGeometryForCloseCheck.coordinates.length - 1\n        ]\n      ) < this.pointerDistance\n    ) {\n      this.setCursor(this.cursors.close);\n\n      if (!this.moveLineId) {\n        return;\n      }\n      if (this.store.has(this.moveLineId)) {\n        this.store.delete([this.moveLineId]);\n      }\n      this.moveLineId = undefined;\n      return;\n    }\n\n    const currentLineGeometry = this.store.getGeometryCopy<LineString>(\n      this.currentId\n    );\n\n    if (!currentLineGeometry) {\n      return;\n    }\n\n    const eventCoord = [event.lng, event.lat] as Position;\n\n    const closestPoint = this.routing.getClosestNetworkCoordinate(eventCoord);\n\n    if (!closestPoint) {\n      return;\n    }\n\n    const length = currentLineGeometry.coordinates.length - 1;\n\n    const geojsonRoute = this.routing.getRoute(\n      currentLineGeometry.coordinates[length],\n      closestPoint\n    );\n\n    if (!geojsonRoute) {\n      return;\n    }\n\n    if (!this.moveLineId) {\n      const [createdId] = this.store.create([\n        {\n          geometry: geojsonRoute.geometry,\n          properties: { mode: this.mode, isDrawnRoute: true, routeId: this.routeId },\n        },\n      ]);\n\n      this.moveLineId = createdId as string;\n    } else {\n      this.store.updateGeometry([\n        {\n          id: this.moveLineId,\n          geometry: geojsonRoute.geometry,\n        },\n      ]);\n    }\n  }\n\n  /** @internal */\n  onClick(event: TerraDrawMouseEvent) {\n    if (event.button === \"right\") {\n      return;\n    }\n\n    const eventCoord = [event.lng, event.lat] as Position;\n\n    if (this.currentId && !this.store.has(this.currentId)) {\n      this.currentId = undefined;\n      this.currentCoordinate = 0;\n      this.currentPointIds = [];\n    }\n\n    if (this.currentId) {\n      const currentLineGeometry = this.store.getGeometryCopy<LineString>(\n        this.currentId\n      );\n\n      if (\n        this.measure(\n          event,\n          currentLineGeometry.coordinates[\n          currentLineGeometry.coordinates.length - 1\n          ]\n        ) < this.pointerDistance\n      ) {\n        if (this.currentCoordinate === 1) {\n          this.store.delete(this.currentPointIds);\n        }\n\n        this.close();\n\n        return;\n      }\n    } else {\n      this.routeId++;\n    }\n\n    let closestPoint = this.routing.getClosestNetworkCoordinate(eventCoord);\n\n    if (this.currentCoordinate === 0) {\n      if (closestPoint) {\n        const [createdId, pointId] = this.store.create([\n          {\n            geometry: {\n              type: \"LineString\",\n              coordinates: [closestPoint],\n            },\n            properties: { mode: this.mode, isDrawnRoute: true, routeId: this.routeId },\n          },\n          {\n            geometry: {\n              type: \"Point\",\n              coordinates: closestPoint,\n            },\n            properties: { mode: this.mode, isDrawnRoute: true, routeId: this.routeId },\n          },\n        ]);\n\n        this.currentId = createdId as string;\n        this.currentPointIds.push(pointId as string);\n        this.currentCoordinate++;\n\n        if (this.state === \"started\") {\n          this.setDrawing();\n        }\n      }\n    } else if (this.currentCoordinate === 1 && this.currentId && closestPoint) {\n      const currentLineGeometry = this.store.getGeometryCopy<LineString>(\n        this.currentId\n      );\n\n      const geojsonRoute = this.routing.getRoute(\n        currentLineGeometry.coordinates[0],\n        closestPoint\n      );\n      if (geojsonRoute) {\n        this.store.updateGeometry([\n          {\n            id: this.currentId,\n            geometry: geojsonRoute?.geometry,\n          },\n        ]);\n\n        const [pointId] = this.store.create([\n          {\n            geometry: {\n              type: \"Point\",\n              coordinates: closestPoint,\n            },\n            properties: { mode: this.mode, isDrawnRoute: true, routeId: this.routeId },\n          },\n        ]);\n\n        this.currentCoordinate = 2;\n        this.currentPointIds.push(pointId as string);\n      }\n\n      if (this.maxPoints === 1) {\n        this.close();\n\n        return;\n      }\n    } else if (\n      this.currentCoordinate > 1 &&\n      this.currentId &&\n      closestPoint &&\n      this.currentCoordinate <= this.maxPoints\n    ) {\n      const currentLineGeometry = this.store.getGeometryCopy<LineString>(\n        this.currentId\n      );\n\n      const length = currentLineGeometry.coordinates.length - 1;\n\n      const geojsonRoute = this.routing.getRoute(\n        currentLineGeometry.coordinates[length],\n        closestPoint\n      );\n\n      if (geojsonRoute) {\n        const newGeometry = {\n          ...currentLineGeometry,\n          coordinates: [\n            ...currentLineGeometry.coordinates,\n            ...geojsonRoute.geometry.coordinates,\n          ],\n        };\n\n        this.store.updateGeometry([\n          {\n            id: this.currentId,\n            geometry: newGeometry,\n          },\n        ]);\n\n        const [pointId] = this.store.create([\n          {\n            geometry: {\n              type: \"Point\",\n              coordinates: closestPoint,\n            },\n            properties: { mode: this.mode, isDrawnRoute: true, routeId: this.routeId },\n          },\n        ]);\n\n        if (this.maxPoints === this.currentCoordinate) {\n          this.close();\n        } else {\n          this.currentCoordinate++;\n          this.currentPointIds.push(pointId as string);\n        }\n      }\n    }\n  }\n\n  /** @internal */\n  onKeyDown() { }\n\n  /** @internal */\n  onKeyUp(event: TerraDrawKeyboardEvent) {\n    if (event.key === this.keyEvents.cancel) {\n      this.cleanUp();\n    }\n\n    if (event.key === this.keyEvents.finish) {\n      this.close();\n    }\n  }\n\n  /** @internal */\n  onDragStart() { }\n\n  /** @internal */\n  onDrag() { }\n\n  /** @internal */\n  onDragEnd() { }\n\n  /** @internal */\n  cleanUp() {\n    try {\n      if (this.currentId) {\n        this.store.delete([this.currentId, ...this.currentPointIds]);\n      }\n    } catch (error) { }\n\n    this.currentId = undefined;\n    this.moveLineId = undefined;\n    this.currentCoordinate = 0;\n    if (this.state === \"drawing\") {\n      this.setStarted();\n    }\n  }\n\n  /** @internal */\n  styleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {\n    const styles = TerraDrawExtend.getDefaultStyling();\n\n    if (\n      feature.type === \"Feature\" &&\n      feature.geometry.type === \"LineString\" &&\n      feature.properties.mode === this.mode\n    ) {\n      styles.lineStringColor = this.getHexColorStylingValue(this.styles.lineStringColor, \"#B90E0A\", feature);\n      styles.lineStringWidth = this.getNumericStylingValue(this.styles.lineStringWidth, 4, feature);\n      styles.zIndex = 10;\n\n      return styles;\n    } else if (\n      feature.type === \"Feature\" &&\n      feature.geometry.type === \"Point\" &&\n      feature.properties.mode === this.mode\n    ) {\n      styles.pointColor = this.getHexColorStylingValue(this.styles.routePointColor, \"#B90E0A\", feature);\n      styles.pointOutlineColor = this.getHexColorStylingValue(this.styles.routePointColor, \"#B90E0A\", feature);\n      styles.pointOutlineWidth = this.getNumericStylingValue(this.styles.routePointOutlineWidth, 1, feature);\n\n      return styles;\n    }\n\n    return styles;\n  }\n\n  validateFeature(feature: unknown): ReturnType<Validation> {\n    return super.validateFeature(feature)\n  }\n\n  afterFeatureAdded(feature: GeoJSONStoreFeatures) { }\n\n}\n\nexport { Routing, type RouteFinder, type RoutingInterface } from \"./routing\";"],"names":["ARRAY_TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","KDBush","constructor","numItems","nodeSize","ArrayType","data","ids","coords","_pos","_finished","this","IndexArrayType","isNaN","Error","Math","min","max","arrayTypeIndex","indexOf","coordsByteSize","BYTES_PER_ELEMENT","idsByteSize","padCoords","ArrayBuffer","set","add","x","y","index","finish","numAdded","sort","left","right","axis","m","select","k","n","z","log","s","exp","sd","sqrt","floor","t","i","j","swapItem","swap","arr","tmp","TinyQueue","compare","a","b","length","_down","push","item","_up","pop","top","bottom","peek","pos","parent","current","halfLength","bestChild","rad","PI","boxDist","lng","lat","cosLat","node","minLng","maxLng","minLat","maxLat","haverSin","haverSinDLng","extremumLat","cosDLng","atan","tan","vertexLat","haverSinDistPartial","compareDist","dist","theta","sin","cosLat1","lat1","lat2","cos","haverSinDist","lng1","lng2","Routing","options","useCache","indexedNetworkPoints","points","routeFinder","network","routeCache","initialise","features","forEach","feature","geometry","coordinates","coordinate","getClosestNetworkCoordinate","inputCoordinate","aroundInput","maxResults","Infinity","maxDistance","maxHaverSinDist","result","undefined","q","id","midLng","midLat","nextAxis","leftNode","rightNode","candidate","around","setRouteFinder","setNetwork","getRoute","startCoord","endCoord","routeKey","route","type","properties","defaultKeyEvents","cancel","defaultCursors","draw","close","TerraDrawBaseDrawMode","TerraDrawExtend","TerraDrawRouteSnapMode","super","mode","currentCoordinate","currentId","keyEvents","cursors","maxPoints","moveLineId","routing","currentPointIds","routeId","pixelDistance","pointOne","pointTwo","x1","y1","x2","y2","latestEvent","updateOptions","cleanUp","_extends","measure","clickEvent","secondCoordinate","project","containerX","containerY","state","setStarted","registerBehaviors","config","start","setCursor","stop","setStopped","onMouseMove","event","requestAnimationFrame","processMouseMove","store","has","currentLineGeometryForCloseCheck","getGeometryCopy","pointerDistance","delete","currentLineGeometry","closestPoint","geojsonRoute","updateGeometry","createdId","create","isDrawnRoute","onClick","button","eventCoord","pointId","setDrawing","newGeometry","onKeyDown","onKeyUp","key","onDragStart","onDrag","onDragEnd","error","styleFeature","styles","getDefaultStyling","lineStringColor","getHexColorStylingValue","lineStringWidth","getNumericStylingValue","zIndex","pointColor","routePointColor","pointOutlineColor","pointOutlineWidth","routePointOutlineWidth","validateFeature","afterFeatureAdded"],"mappings":"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"}